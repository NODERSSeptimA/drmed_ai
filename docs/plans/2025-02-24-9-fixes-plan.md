# 9 Bug Fixes & Feature Improvements — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Fix 9 reported bugs and improvements in the MedAI psychiatric examination system — multi-select storage, blood pressure mask, DOCX generation (somatic/dynamics/conclusion/diagnosis), examination plan options, dynamics visibility, and new DOCX templates with updated fonts/styles.

**Architecture:** Changes span three layers: (1) JSON template config, (2) React UI components, (3) DOCX generator. No database schema changes needed — `visitType` field already exists in Prisma. The multi-select storage format change requires backward-compatible parsing.

**Tech Stack:** Next.js 16, React 19, TypeScript 5, shadcn/ui, `docx` library for DOCX generation, Tailwind v4

---

### Task 1: Fix MultiSelectField storage — comma-in-option bug (Issue 1)

**Files:**
- Modify: `components/medical-history/field-components/multi-select-field.tsx`

**Context:** The field stores selected values as a comma-separated string `"A, B, C"`. The option `"Опрятен, подтянут"` contains a comma, so `split(",")` splits it into two fragments. Neither fragment matches the original on toggle → can't deselect, duplicates on re-select.

**Step 1: Add parseMultiSelectValue helper and update component**

Replace the entire `multi-select-field.tsx` with this approach:
- Parse: try `JSON.parse(value)` (returns array). If it fails or isn't an array, fall back to `value.split(",").map(s => s.trim()).filter(Boolean)`.
- Store: always `JSON.stringify(selectedArray)` — e.g. `'["Опрятен, подтянут","Поведение адекватное обстановке"]'`
- Display: `selectedArray.join(", ")` for button label and view mode.

```tsx
// New parse helper — top of file
function parseMultiSelectValue(value: string, options: string[]): string[] {
  if (!value) return []
  try {
    const parsed = JSON.parse(value)
    if (Array.isArray(parsed)) return parsed
  } catch { /* not JSON — legacy comma-separated format */ }
  // Legacy: try to match known options greedily
  const result: string[] = []
  let remaining = value
  while (remaining.length > 0) {
    remaining = remaining.replace(/^[\s,]+/, "")
    if (!remaining) break
    // Try to match longest known option first
    const match = options
      .filter((o) => remaining.toLowerCase().startsWith(o.toLowerCase()))
      .sort((a, b) => b.length - a.length)[0]
    if (match) {
      result.push(match)
      remaining = remaining.slice(match.length)
    } else {
      // Skip to next comma
      const idx = remaining.indexOf(",")
      if (idx === -1) {
        result.push(remaining.trim())
        break
      }
      result.push(remaining.slice(0, idx).trim())
      remaining = remaining.slice(idx + 1)
    }
  }
  return result.filter(Boolean)
}
```

Update the component:
- Replace `selectedItems` derivation: `const selectedItems = parseMultiSelectValue(value, options)`
- In `toggle()`: store as `onChange(JSON.stringify(next))` and `onChange(JSON.stringify([...selectedItems, option]))`
- Display label: `selectedItems.join(", ")`
- View mode display: `parseMultiSelectValue(value, options).join(", ") || "—"`

**Step 2: Build and verify**

Run: `npm run build`
Expected: No TypeScript errors

**Step 3: Commit**

```bash
git add components/medical-history/field-components/multi-select-field.tsx
git commit -m "fix: multi-select stores JSON array instead of comma-separated string

Fixes toggle bug with options containing commas (e.g. 'Опрятен, подтянут').
Backward-compatible: legacy comma-separated values parsed via greedy option matching."
```

---

### Task 2: Blood pressure input mask (Issue 2)

**Files:**
- Create: `components/medical-history/field-components/blood-pressure-field.tsx`
- Modify: `components/medical-history/section-renderer.tsx:80-143` (add case in switch)
- Modify: `templates/psychiatry-examination.json:359-363` (change type)

**Step 1: Create BloodPressureField component**

```tsx
"use client"

import { Input } from "@/components/ui/input"

interface BloodPressureFieldProps {
  label: string
  value: string
  editing: boolean
  onChange: (value: string) => void
}

export function BloodPressureField({ label, value, editing, onChange }: BloodPressureFieldProps) {
  const parts = value.split("/")
  const systolic = parts[0] || ""
  const diastolic = parts[1] || ""

  function handleChange(sys: string, dia: string) {
    onChange(sys || dia ? `${sys}/${dia}` : "")
  }

  if (!editing) {
    return (
      <div className="flex flex-col gap-0.5">
        <span className="text-xs text-muted-foreground">{label}</span>
        <span className="text-sm">{value || "—"}</span>
      </div>
    )
  }

  return (
    <div className="space-y-1">
      <span className="text-xs text-muted-foreground">{label}</span>
      <div className="flex items-center gap-1.5">
        <Input
          type="number"
          min={40}
          max={300}
          placeholder="120"
          value={systolic}
          onChange={(e) => handleChange(e.target.value, diastolic)}
          className="w-20 text-center"
        />
        <span className="text-lg font-medium text-muted-foreground">/</span>
        <Input
          type="number"
          min={30}
          max={200}
          placeholder="80"
          value={diastolic}
          onChange={(e) => handleChange(systolic, e.target.value)}
          className="w-20 text-center"
        />
        <span className="text-xs text-muted-foreground ml-1">мм рт. ст.</span>
      </div>
    </div>
  )
}
```

**Step 2: Add routing in section-renderer.tsx**

In `section-renderer.tsx`, add import at top:
```tsx
import { BloodPressureField } from "./field-components/blood-pressure-field"
```

In the `renderField` function's switch statement (around line 80), add case before `default`:
```tsx
case "blood-pressure":
  return (
    <BloodPressureField
      key={field.id}
      label={field.label}
      value={(value as string) || ""}
      editing={editing}
      onChange={(v) => onFieldChange(field.id, v)}
    />
  )
```

**Step 3: Update template JSON**

In `templates/psychiatry-examination.json`, change `blood_pressure` field type from `"text"` to `"blood-pressure"`:

```json
{
  "id": "blood_pressure",
  "label": "Артериальное давление (мм рт. ст.)",
  "type": "blood-pressure",
  "required": true
}
```

**Step 4: Build and verify**

Run: `npm run build`

**Step 5: Commit**

```bash
git add components/medical-history/field-components/blood-pressure-field.tsx \
      components/medical-history/section-renderer.tsx \
      templates/psychiatry-examination.json
git commit -m "feat: add blood pressure input mask with systolic/diastolic fields"
```

---

### Task 3: Update examination plan options (Issue 8)

**Files:**
- Modify: `templates/psychiatry-examination.json:601-616`

**Step 1: Update options array and labels**

In the `examination_plan` section:
- Remove from options: `"ОАК"`, `"Глюкоза крови"`, `"Шкала Гамильтона (HDRS)"`
- Add to options: `"Клинический анализ крови"`, `"КТ головного мозга"`
- Update `description`: replace `"ОАМ, ОАК, глюкоза крови"` with `"ОАМ, клинический анализ крови"`
- Update field `label`: similarly

New options array:
```json
["Клинический анализ крови", "ОАМ", "Биохимический анализ крови", "ЭКГ", "УЗИ", "ФГ органов грудной клетки", "КТ головного мозга", "МРТ головного мозга", "ЭЭГ", "Консультация терапевта", "Консультация невролога", "Консультация эндокринолога"]
```

New section description:
```
"Консультации специалистов, ЭКГ, УЗИ, ФГ, ОАМ, клинический анализ крови, биохимический анализ крови"
```

New field label:
```
"План обследования (консультации специалистов, ЭКГ, УЗИ, ФГ, ОАМ, анализ крови)"
```

**Step 2: Build and verify**

Run: `npm run build`

**Step 3: Commit**

```bash
git add templates/psychiatry-examination.json
git commit -m "fix: update examination plan options — remove OAK/glucose/Hamilton, add clinical blood test/CT"
```

---

### Task 4: Dynamics — add "Нет" option + restrict to repeat visits (Issue 4)

**Files:**
- Modify: `templates/psychiatry-examination.json:464-547` (add onlyForRepeated, add "Нет")
- Modify: `components/medical-history/section-renderer.tsx` (section-level visibility)
- Modify: `app/medical-history/[id]/page.tsx:276-285` (pass visitType)

**Step 1: Update template — add "Нет" to each dynamics select + onlyForRepeated**

In `templates/psychiatry-examination.json`, in the `dynamics` section object, add property:
```json
"onlyForRepeated": true
```

For every select field inside `dynamics`, prepend `"Нет"` to the `options` array. Example for `dynamics_direction`:
```json
"options": ["Нет", "Состояние улучшилось", "Стабилизировалось", ...]
```

Do this for all 11 fields: `dynamics_direction`, `dynamics_consciousness`, `dynamics_orientation`, `dynamics_productive`, `dynamics_behavior`, `dynamics_mood`, `dynamics_activity`, `dynamics_sleep`, `dynamics_appetite`, `dynamics_criticism`, `dynamics_compliance`.

**Step 2: Update SectionRenderer props and page to pass visitType**

In `section-renderer.tsx`, add `visitType?: string` to `SectionRendererProps`:
```tsx
interface SectionRendererProps {
  section: {
    id: string
    title: string
    icon: string
    description?: string
    fields?: FieldDef[]
    onlyForRepeated?: boolean  // new
  }
  sectionIndex: number
  data: Record<string, unknown>
  editing: boolean
  onFieldChange: (fieldId: string, value: unknown) => void
  visitType?: string  // new
}
```

At the top of the `SectionRenderer` function, add early return:
```tsx
// Hide section for first visits if onlyForRepeated
if (section.onlyForRepeated && visitType !== "repeat") {
  return null
}
```

In `app/medical-history/[id]/page.tsx`, pass `visitType` to `SectionRenderer`:
```tsx
<SectionRenderer
  key={section.id}
  section={section}
  sectionIndex={index}
  data={formData[section.id] || {}}
  editing={editing}
  onFieldChange={(fieldId, value) => handleFieldChange(section.id, fieldId, value)}
  visitType={history.visitType}  // new
/>
```

Note: currently `visitType` is `"home"` or `"clinic"` (location type). We need a separate concept for "first vs repeat". For now, we'll check whether the patient has prior medical histories. But the simplest approach: add a `visitOrder` concept.

**Pragmatic approach:** Since the MedicalHistory response already has `visitType` for location, let's add a UI toggle or detect from DB. Simplest: check if the patient has other completed medical histories. Pass a prop `isRepeatVisit: boolean`.

In `app/medical-history/[id]/page.tsx`, add to `MedicalHistoryResponse`:
```tsx
isRepeatVisit?: boolean
```

In the API route `app/api/medical-history/[id]/route.ts` (GET), after fetching the history, count prior histories:
```tsx
const priorCount = await prisma.medicalHistory.count({
  where: {
    patientId: history.patientId,
    id: { not: history.id },
    status: "completed",
  },
})
// Add to response: isRepeatVisit: priorCount > 0
```

Then in the page, pass:
```tsx
visitType={history.isRepeatVisit ? "repeat" : "first"}
```

**Step 3: Build and verify**

Run: `npm run build`

**Step 4: Commit**

```bash
git add templates/psychiatry-examination.json \
      components/medical-history/section-renderer.tsx \
      app/medical-history/[id]/page.tsx \
      app/api/medical-history/[id]/route.ts
git commit -m "feat: dynamics section only for repeat visits + 'Нет' option to exclude sub-fields"
```

---

### Task 5: Fix DOCX generator — somatic-neuro, dynamics, mental status field mismatches (Issue 3)

**Files:**
- Modify: `lib/docx/generator.ts:368-391` (somatic, dynamics) + `329-348` (emotional, thinking, sensation)

**Step 1: Add composeSectionText helper**

Add this helper function in `generator.ts` after the existing helpers (around line 158):

```tsx
/** Compose text from individual template fields in a section */
function composeSectionText(
  sectionData: Record<string, unknown>,
  fields: Array<{ id: string; label: string; type: string }>,
  options?: { skipValues?: string[]; separator?: string }
): string {
  const skipValues = options?.skipValues || ["Нет"]
  const separator = options?.separator || ". "
  const parts: string[] = []

  for (const field of fields) {
    const raw = sectionData[field.id]
    if (!raw) continue
    let val = String(raw)

    // Parse multi-select JSON arrays
    if (field.type === "multi-select") {
      try {
        const arr = JSON.parse(val)
        if (Array.isArray(arr)) val = arr.join(", ")
      } catch { /* legacy comma format is fine */ }
    }

    if (!val || skipValues.includes(val)) continue
    parts.push(`${field.label}: ${val}`)
  }
  return parts.join(separator)
}
```

**Step 2: Rewrite somatic-neurological section (lines 368-379)**

Replace:
```tsx
const som = d.somatic_neurological || {}
const somVal = String(som.somatic_neuro_text || "")
```

With:
```tsx
const som = d.somatic_neurological || {}
const somSection = input.sections.find((s) => s.id === "somatic_neurological")
const somVal = String(som.somatic_neuro_text || "") || composeSectionText(
  som as Record<string, unknown>,
  (somSection?.fields || []) as Array<{ id: string; label: string; type: string }>
)
```

This checks `somatic_neuro_text` first (backward compat), then falls back to composing from individual fields.

**Step 3: Rewrite dynamics section (lines 382-391)**

Replace:
```tsx
const dyn = d.dynamics || {}
const dynVal = String(dyn.dynamics_text || "")
```

With:
```tsx
const dyn = d.dynamics || {}
const dynSection = input.sections.find((s) => s.id === "dynamics")
const dynVal = String(dyn.dynamics_text || "") || composeSectionText(
  dyn as Record<string, unknown>,
  (dynSection?.fields || []) as Array<{ id: string; label: string; type: string }>,
  { skipValues: ["Нет", ""] }
)
```

**Step 4: Fix emotional disorders (line 329)**

Replace:
```tsx
p1.push(fieldLine("Эмоциональные нарушения:", String(ms.emotional_disorders || "")))
```

With:
```tsx
const emotionalParts = [
  ms.emotional_mood && `${ms.emotional_mood}`,
  ms.emotional_reactivity && `${ms.emotional_reactivity}`,
  ms.emotional_depth && `${ms.emotional_depth}`,
].filter(Boolean)
const emotionalVal = String(ms.emotional_disorders || "") || emotionalParts.join(", ")
p1.push(fieldLine("Эмоциональные нарушения:", emotionalVal))
```

**Step 5: Fix thinking disorders (line 335)**

Replace:
```tsx
const thinkVal = String(ms.thinking_disorders || "")
```

With:
```tsx
const thinkParts = [
  ms.thinking_tempo && `темп: ${ms.thinking_tempo}`,
  ms.thinking_form && `форма: ${ms.thinking_form}`,
  ms.thinking_content && `содержание: ${ms.thinking_content}`,
].filter(Boolean)
const thinkVal = String(ms.thinking_disorders || "") || thinkParts.join("; ")
```

**Step 6: Fix sensation disorders (lines 347-348)**

Replace:
```tsx
p1.push(fieldLine("- количественные (анестезия, гипо-, гиперстезия)", String(ms.sensation_quantitative || "")))
p1.push(fieldLine("- качественные (синестезия, парестезия)", String(ms.sensation_qualitative || "")))
```

With:
```tsx
// Parse multi-select sensation_disorders field
let sensationVal = String(ms.sensation_disorders || "")
try {
  const arr = JSON.parse(sensationVal)
  if (Array.isArray(arr)) sensationVal = arr.join(", ")
} catch { /* legacy format */ }
const sensQuantitative = String(ms.sensation_quantitative || "") || sensationVal
p1.push(fieldLine("- количественные (анестезия, гипо-, гиперстезия)", sensQuantitative))
p1.push(fieldLine("- качественные (синестезия, парестезия)", String(ms.sensation_qualitative || "")))
```

**Step 7: Build and verify**

Run: `npm run build`

**Step 8: Commit**

```bash
git add lib/docx/generator.ts
git commit -m "fix: DOCX generator composes text from individual template fields

Fixes somatic-neurological, dynamics, emotional disorders, thinking disorders,
and sensation disorders not appearing in exported DOCX."
```

---

### Task 6: Fix conclusion text placement + disorder level display (Issues 5 + 6)

**Files:**
- Modify: `lib/docx/generator.ts:393-422`

**Step 1: Rewrite conclusion paragraph (lines 396-408)**

Replace the entire conclusion block:
```tsx
p2.push(new Paragraph({
  spacing: { before: 80, after: 20 },
  children: [
    t("Заключение: ", { bold: true }),
    t("выявленные особенности психического статуса "),
    t(conFeatures || "______", { underline: true }),
    t(" указывают на наличие психического расстройства. В клинической картине отмечаются следующие симптомы:"),
  ],
}))
if (!conFeatures) {
  p2.push(blankULine())
  p2.push(blankULine())
}
```

With:
```tsx
p2.push(new Paragraph({
  spacing: { before: 80, after: 20 },
  children: [
    t("Заключение: ", { bold: true }),
    t("выявленные особенности психического статуса указывают на наличие психического расстройства. В клинической картине отмечаются следующие симптомы:"),
  ],
}))
if (conFeatures) {
  p2.push(new Paragraph({ spacing: { after: 20 }, children: [t(conFeatures)] }))
} else {
  p2.push(blankULine())
  p2.push(blankULine())
}
```

**Step 2: Rewrite disorder level display (lines 413-422)**

Replace:
```tsx
p2.push(new Paragraph({
  spacing: { before: 60, after: 20 },
  children: [
    t("Уровень нарушений: ", { bold: true }),
    t(disLevel || "___", { underline: true }),
    t(" психотический / дефицитарный. Исходя из данных истории болезни, анамнеза и состояния пациента, тип реагирования определяется как: "),
    t(reactType || "эндогенный / экзогенно-органический / психогенный / смешанный"),
  ],
}))
if (!disLevel) p2.push(blankULine())
```

With:
```tsx
p2.push(new Paragraph({
  spacing: { before: 60, after: 20 },
  children: [
    t("Уровень нарушений: "),
    t(disLevel || "\t\t\t\t", disLevel ? {} : { underline: true }),
    t(". Исходя из данных истории болезни, анамнеза и состояния пациента, тип реагирования определяется как: "),
    t(reactType || "\t\t\t\t", reactType ? {} : { underline: true }),
  ],
}))
```

When a value IS selected (e.g., "Непсихотический"), the output will be:
```
Уровень нарушений: Непсихотический. Исходя из данных..., тип реагирования определяется как: Психогенный
```

When no value selected, blank tabs with underline serve as fill-in placeholders.

**Step 3: Also fix the section-renderer.tsx view display (line 300-305)**

In `section-renderer.tsx`, the conclusion view block also shows the hardcoded "психотический / дефицитарный." text. Replace lines 300-305:

```tsx
<DiagnosisBlock variant="yellow" label="Уровень нарушений">
  <p>
    <strong>{(data.disorder_level as string) || "—"}</strong>
    {" "}психотический / дефицитарный. Тип реагирования:{" "}
    <strong>{(data.reaction_type as string) || "—"}</strong>
  </p>
</DiagnosisBlock>
```

With:
```tsx
<DiagnosisBlock variant="yellow" label="◆ Уровень нарушений">
  <p>
    <strong>{(data.disorder_level as string) || "—"}</strong>
    {" "}Тип реагирования:{" "}
    <strong>{(data.reaction_type as string) || "—"}</strong>
  </p>
</DiagnosisBlock>
```

**Step 4: Build and verify**

Run: `npm run build`

**Step 5: Commit**

```bash
git add lib/docx/generator.ts components/medical-history/section-renderer.tsx
git commit -m "fix: conclusion text placement after colon + show only selected disorder level

Issue 5: dictated text now appears after 'следующие симптомы:' not mid-sentence
Issue 6: only selected disorder_level value shown, no hardcoded alternatives"
```

---

### Task 7: Fix diagnosis text missing in DOCX (Issue 7)

**Files:**
- Modify: `lib/docx/generator.ts:424-433`
- Potentially: `app/api/medical-history/[id]/export/route.ts`

**Step 1: Add defensive diagnosis text extraction**

The generator currently reads `diag.diagnosis_text`. The field id is `diagnosis_text` and it's in section `diagnosis`, so data is at `d.diagnosis.diagnosis_text`. This should work if the data is saved correctly.

Add a fallback and debug log. Replace:
```tsx
const diag = d.diagnosis || {}
const diagVal = String(diag.diagnosis_text || "")
```

With:
```tsx
const diag = d.diagnosis || {}
// Try field id directly, then try any string-valued key as fallback
let diagVal = String(diag.diagnosis_text || "")
if (!diagVal) {
  // Fallback: look for any non-icd prose value in diagnosis section
  for (const [key, val] of Object.entries(diag)) {
    if (key !== "icd_code" && typeof val === "string" && val.length > 3) {
      diagVal = val
      break
    }
  }
}
```

**Step 2: Build and verify**

Run: `npm run build`

**Step 3: Commit**

```bash
git add lib/docx/generator.ts
git commit -m "fix: defensive diagnosis text extraction with fallback for missing field key"
```

---

### Task 8: New DOCX templates + Cambria/Calibri fonts + remove borders (Issue 9)

**Files:**
- Replace: `templates/Denasty/Шаблон бланка осмотра.docx` → `Шаблон осмотра (психиатр) новый.docx`
- Replace: `templates/Denasty/Выездной шаблон бланка осмотра.docx` → `Шаблон_осмотра_психиатр_Династия_18_новый.docx`
- Modify: `lib/docx/generator.ts` (fonts, header, margins, blankULine, profiles)

**Step 1: Rename/replace template files**

```bash
cd templates/Denasty
# Keep old files as backup briefly, then replace
mv "Шаблон бланка осмотра.docx" "Шаблон бланка осмотра.docx.bak"
mv "Выездной шаблон бланка осмотра.docx" "Выездной шаблон бланка осмотра.docx.bak"
cp "Шаблон осмотра (психиатр) новый.docx" "Шаблон бланка осмотра.docx"
cp "Шаблон_осмотра_психиатр_Династия_18_новый.docx" "Выездной шаблон бланка осмотра.docx"
rm *.bak
rm "Шаблон осмотра (психиатр) новый.docx" "Шаблон_осмотра_психиатр_Династия_18_новый.docx"
```

Alternatively: just update the `templateFile` references in COMPANY_PROFILES to point to the new filenames.

Best approach: **rename new files to match existing filenames** so we don't break the profile references.

**Step 2: Update font constants in generator.ts**

Replace:
```tsx
const FONT = "Arial"
```
With:
```tsx
const FONT = "Calibri"
const FONT_HEADING = "Cambria"
```

**Step 3: Update helper `t()` to support heading font**

No change needed in `t()` — it always uses `FONT`. For section headings, create a variant or pass `font` option. Add to the `t()` function opts:

```tsx
function t(s: string, opts?: Partial<{ bold: boolean; underline: boolean; size: number; italic: boolean; font: string }>): TextRun {
  return new TextRun({
    text: s,
    font: opts?.font ?? FONT,
    size: opts?.size ?? SZ,
    bold: opts?.bold,
    underline: opts?.underline ? {} : undefined,
    italics: opts?.italic,
  })
}
```

Update `sectionTitle()` to use heading font:
```tsx
function sectionTitle(title: string, opts?: { size?: number; before?: number }): Paragraph {
  return new Paragraph({
    children: [t(title, { bold: true, size: opts?.size, font: FONT_HEADING })],
    spacing: { before: opts?.before ?? 80, after: 40 },
  })
}
```

**Step 4: Update margins**

The new templates use `457200 EMU` for all margins. Converting: `457200 EMU / 914400 * 1440 = 720 twips = 12.7mm`.

Replace:
```tsx
const margin = { top: 680, bottom: 850, left: 1134, right: 850 }
```
With:
```tsx
const margin = { top: 720, bottom: 720, left: 720, right: 720 }
```

**Step 5: Replace header table builder with simple paragraphs**

The new templates don't use a table for the header — they use right-aligned paragraphs with a logo image.

Replace the `buildHeaderTable` function with a `buildHeaderParagraphs` function that returns `Paragraph[]`:

```tsx
function buildHeaderParagraphs(logoData: Buffer | null, profile: typeof COMPANY_PROFILES[keyof typeof COMPANY_PROFILES]): Paragraph[] {
  const paras: Paragraph[] = []

  if (logoData) {
    paras.push(new Paragraph({
      alignment: AlignmentType.LEFT,
      spacing: { after: 40 },
      children: [new ImageRun({ data: logoData, transformation: { width: LOGO_W, height: LOGO_H }, type: "png" })],
    }))
  }

  const lines = [
    { text: profile.name, bold: true, size: SZ_CO },
    { text: profile.address, size: SZ_SM },
    { text: profile.phone, size: SZ_SM },
    { text: profile.email, size: SZ_SM },
    { text: profile.website, size: SZ_SM },
  ]

  for (const l of lines) {
    paras.push(new Paragraph({
      alignment: AlignmentType.RIGHT,
      spacing: { after: 0 },
      children: [t(l.text, { bold: l.bold, size: l.size })],
    }))
  }

  return paras
}
```

Update the Document creation to use `...buildHeaderParagraphs(...)` instead of `buildHeaderTable(...)`:
```tsx
children: [...buildHeaderParagraphs(logoData, profile), ...p1],
```

**Step 6: Replace blankULine with simple empty paragraph**

Replace the `blankULine()` function:
```tsx
function blankULine(): Paragraph {
  return new Paragraph({
    spacing: { after: 40 },
    children: [t(" ")],
  })
}
```

This removes the `border: { bottom: ... }` completely — just an empty paragraph with a space character.

**Step 7: Update DOCX examination plan header text**

In the examination plan output (around lines 447-462), update the hardcoded description to match new options:

Replace:
```tsx
t("(консультации специалистов, ЭКГ, УЗИ, ФГ, ОАМ, ОАК, глюкоза крови,", { bold: true }),
```
and
```tsx
t("биохимический анализ крови) ", { bold: true }),
```

With:
```tsx
t("(консультации специалистов, ЭКГ, УЗИ, ФГ, ОАМ, клинический анализ крови,", { bold: true }),
```
and
```tsx
t("биохимический анализ крови) ", { bold: true }),
```

**Step 8: Build and verify**

Run: `npm run build`

**Step 9: Test DOCX export manually**

Start dev server, open an existing medical history, click "Экспорт в Word". Open the downloaded .docx:
- Verify Calibri font for body, Cambria for section headings
- Verify no black border/frame on pages
- Verify no underlined blank lines (just empty spaces)
- Verify header shows logo + right-aligned company info (not in a table)
- Verify all section data appears correctly

**Step 10: Commit**

```bash
git add templates/Denasty/ lib/docx/generator.ts
git commit -m "feat: new DOCX templates with Calibri/Cambria fonts, remove borders

Updated templates from clinic. Fonts: Calibri (body), Cambria (headings).
Header: simple paragraphs instead of table. Removed underlined blank lines.
Margins: uniform 12.7mm all sides."
```

---

### Task 9: Final build verification + lint

**Step 1: Run lint**

```bash
npm run lint
```

Fix any lint errors.

**Step 2: Run full build**

```bash
npm run build
```

Ensure clean build with no errors.

**Step 3: Commit any remaining fixes**

```bash
git add -A
git commit -m "chore: lint fixes"
```

---

## Execution Order Summary

| Task | Issue | Files | Risk |
|------|-------|-------|------|
| 1 | #1 multi-select | multi-select-field.tsx | Medium (backward compat) |
| 2 | #2 BP mask | blood-pressure-field.tsx + renderer + JSON | Low |
| 3 | #8 exam plan options | JSON | Low |
| 4 | #4 dynamics | JSON + renderer + page + API | Medium |
| 5 | #3 DOCX field mismatches | generator.ts | High (many changes) |
| 6 | #5+#6 conclusion + level | generator.ts + renderer | Medium |
| 7 | #7 diagnosis | generator.ts | Low |
| 8 | #9 templates + fonts | templates + generator.ts | High (full restyle) |
| 9 | Final verify | — | Low |
